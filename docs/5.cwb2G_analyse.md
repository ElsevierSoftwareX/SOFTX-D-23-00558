# cwb2G

## 0. Test code

```python
# set env LD_LIBRARY_PATH to install_path
install_path = "/Users/yumengxu/Project/Physics/cwb/cwb_source/tools/install/lib"

import os

os.environ['LD_LIBRARY_PATH'] = install_path
from pycwb.config import user_parameters
from pycwb import logger_init
logger_init()
config = user_parameters.load_yaml('./user_parameters.yaml', load_to_root=False)

# fetch event from catalog
from pycwb.modules.read_data import read_from_catalog

data, merger, data_wavearray = read_from_catalog('gwtc-2', 'GW190521', 'H1')

# data conditioning
from pycwb.modules.data_conditioning import regression, whitening
data_reg = regression(config, data_wavearray)
data_w_reg = whitening(config, data_reg)
```

## 1. ReadData


### 1.1 Read and check frame

```cpp
for(int i=0; i<nIFO; i++) {   
    fr[i].readFrames(FRF[i],cfg.channelNamesRaw[i],x);
    
    if(TMath::IsNaN(x.mean())) 
    {cout << "cwb2G::ReadData - Error : found NaN in strain data !!!" <<  endl;EXIT(1);}
    
    if(x.rate()!=cfg.inRate)
    {cout << "cwb2G::ReadData - input rate from frame " << x.rate()
          << " do not match the one defined in config : " << cfg.inRate << endl;EXIT(1);}
}    
```

### 1.2 Process raw data 
```cpp
for(int i=0; i<nIFO; i++) { 
    x.start(x.start()+cfg.dataShift[i]);                // dataShift
    x.start(x.start()-cfg.segLen*(segID[i]-segID[0]));  // SLAG
    if(singleDetector) TB.resampleToPowerOfTwo(x);
    if(cfg.dcCal[i]>0.) x*=cfg.dcCal[i];                // DC correction
    if(cfg.fResample>0) x.Resample(cfg.fResample);   	  // RESAMPLING
    x.Resample(x.rate()/(1<<cfg.levelR));		  // resampling
    x*=sqrt(1<<cfg.levelR);				  // rescaling
    
    // save ifo data to temporary job file
    cdstrain->cd();gwavearray<double> gx(x);gx.Write(ifo[i],TObject::kOverwrite);
}
```

### 1.3 Check synchronization (can be ensured by data processing stage?)
```cpp
for(int i=0; i<nIFO; i++) {  
    if(i==0) {xrate=x.rate();xstart=x.start();xsize=x.size();}
    
    fprintf(stdout,"start=%f duration=%f rate=%f\n", x.start(),x.size()/x.rate(),x.rate());
    if(i>0 && xstart != x.start()) {
      cout << "cwb2G::ReadData - Error : ifo noise data not synchronized" << endl;
      cout << ifo[i] << " " << x.start() << " != " << ifo[0] << " " << xstart << endl;
      EXIT(1);
    }
    if(i>0 && xrate != x.rate()) {
      cout << "cwb2G::ReadData - Error : ifo noise data have different rates" << endl;
      cout << ifo[i] << " " << x.rate() << " != " << ifo[0] << " " << xrate << endl;
      EXIT(1);
    }
}
```

## 2. Data Conditioning


Apply regression to remove lines & whiten data

Loop over detectors

 - read ifo strain from job file
 - read MDC data from temporary job file (config::simulation>0)
 - if(config::simulation==1) MDC are rescaled according to the config::factors
 - Add MDC to noise
 - Apply regression to remove lines
 - Use detector::white to estimate noise (detector::nRMS)
 - Use the estimated noise to whiten data (WSeries<double>::white)
 - Store injected waveforms (SaveWaveforms)
 - Store whitened data (detector::HoT) to job file (jfile)
 - Store estimated noise to job file (detector::nRMS)


### 2.1 Inject MDC
```cpp
for(int i=0; i<nIFO; i++) {
    px = (wavearray<double>*)jfile->Get(TString("strain/")+ifo[i]);
    hot[i] = pD[i]->getHoT();
    *hot[i] = *px; delete px;
    xM = *px;				// copy MDC to temporary wavearray
    (*px)*=factor;	
    hot[i]->add(*px);
}
```

### 2.2 2G Data regression
<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
for(int i=0; i<nIFO; i++) {
      pTF[i] = pD[i]->getTFmap();

      // regression
      pTF[i]->Forward(*hot[i],WDMlpr);
      regression rr(*pTF[i],const_cast<char*>("target"),
                    1.,cfg.fHigh);
      rr.add(*hot[i],const_cast<char*>("target"));
      rr.setFilter(REGRESSION_FILTER_LENGTH);
      rr.setMatrix(NET.Edge,REGRESSION_MATRIX_FRACTION);
      rr.solve(REGRESSION_SOLVE_EIGEN_THR,
               REGRESSION_SOLVE_EIGEN_NUM,
               REGRESSION_SOLVE_REGULATOR);
      rr.apply(REGRESSION_APPLY_THR);
      *hot[i] = rr.getClean();
}
```
</td>
<td>

```python
from pycwb.constants import REGRESSION_FILTER_LENGTH, \
   REGRESSION_MATRIX_FRACTION, \
   REGRESSION_SOLVE_EIGEN_THR, REGRESSION_SOLVE_EIGEN_NUM,\
   REGRESSION_SOLVE_REGULATOR, REGRESSION_APPLY_THR,\
   WDM_BETAORDER, WDM_PRECISION


def regression(config: dict, h: TimeSeries):
   """
       Clean data with cWB regression method.
   Input
   ------
   
   config: (dict) configuration dictionary
   h: (TimeSeries) data
   
   Output
   ------
   hh: (ROOT wavearray) cleaned data 
   
   """
   layers = int(config['rateANA'] / 8)
   wdm = ROOT.WDM(np.double)(layers, layers, WDM_BETAORDER, WDM_PRECISION)
   tf_map = ROOT.WSeries(np.double)(h, wdm)
   tf_map.Forward()

   r = ROOT.regression(tf_map, "target", 1., config['fHigh'])
   r.add(h, "target")

   # Calculate prediction
   r.setFilter(REGRESSION_FILTER_LENGTH)  # length of filter
   r.setMatrix(config['segEdge'], REGRESSION_MATRIX_FRACTION)
   r.solve(REGRESSION_SOLVE_EIGEN_THR,
           REGRESSION_SOLVE_EIGEN_NUM,
           REGRESSION_SOLVE_REGULATOR)
   r.apply(REGRESSION_APPLY_THR)

   # cleaned data
   hh = r.getClean()

   return hh

```
</td>
</tr>
</table>


### 2.3 2G Data Whitening

<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
for(int i=0; i<nIFO; i++) {
    // whitening
    pTF[i]->Forward(*hot[i],WDMwhite);
    pTF[i]->setlow(cfg.fLow);
    pTF[i]->sethigh(cfg.fHigh);
    // calculate noise rms 
    pD[i]->white(cfg.whiteWindow,0,cfg.segEdge,
                 cfg.whiteStride);
    // high pass filtering at 16Hz
    pD[i]->nRMS.bandpass(16.,0.,1); 
    // whiten  0 phase WSeries
    pTF[i]->white(pD[i]->nRMS,1);  
    // whiten 90 phase WSeries
    pTF[i]->white(pD[i]->nRMS,-1);  
    
    WSeries<double> wtmp = *pTF[i];
    pTF[i]->Inverse();
    wtmp.Inverse(-2);
    *hot[i] = *pTF[i];
    *hot[i] += wtmp;
    *hot[i] *= 0.5;
    // add infos to history
    sprintf(info,"-IFO:%d-RMS:%g",i,hot[i]->rms());
}
```
</td>
<td>

```python
def whitening(config: dict, h: TimeSeries):
   """
       
   Input
   -----
   h: data to whiten
   edge: extra data to avoid artifacts
   f_min: (int) minimum frequency
   f_max: (int) maximum frequency
   white_window: (float) time window dT. if = 0 - dT=T, where T is wavearray duration - 2*offset
   white_stride: (float) noise sampling interval (window stride), the number of measurements is
                         k=int((T-2*offset)/stride) if stride=0, then stride is set to dT
   
   Output
   ------
   hw: whitened data
   """

   layers_white = 2 ** config['l_white'] if config['l_white'] > 0 else 2 ** config['l_high']

   wdm_white = ROOT.WDM(np.double)(layers_white,
                                   layers_white, 6, 10)

   tf_map = ROOT.WSeries(np.double)(h, wdm_white)
   tf_map.Forward()
   tf_map.setlow(config['fLow'])
   tf_map.sethigh(config['fHigh'])

   # calculate noise rms
   logger.info('calculate noise rms')
   # FIXME: should here be tf_map?
   # FIXME: check the length of data and white parameters to prevent freezing
   nRMS = tf_map.white(config['whiteWindow'], 0, config['segEdge'],
                       config['whiteStride'])

   # high pass filtering at 16Hz
   logger.info('high pass filtering at 16Hz')
   # nRMS.bandpass(16., 0., 1)

   # whiten  0 phase WSeries
   logger.info('whiten  0 phase WSeries')
   tf_map.white(nRMS, 1)
   # whiten 90 phase WSeries
   logger.info('whiten 90 phase WSeries')
   tf_map.white(nRMS, -1)

   wtmp = copy.deepcopy(tf_map)
   tf_map.Inverse()
   wtmp.Inverse(-2)
   tf_map += wtmp
   tf_map *= 0.5

   hw = ut.convert_wseries_to_wavearray(tf_map)

   return hw
```
</td>
</tr>
</table>

Key output: detector `pD`, `hot`

## 3. CWB Init and Network

### 3.1 CWB2G Init

 - Initialize the WDM<double> tranforms for each resolution level used in the analysis
 - Load the xTalk Catalog (network::setMRAcatalog) used for the Multi Resolution Analysis

#### loading MRA catalog
<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
nRES = cfg.l_high-cfg.l_low+1;     // number of frequency resolution levels
sprintf(MRAcatalog,"%s/%s",cfg.filter_dir,cfg.wdmXTalk);
TB.checkFile(MRAcatalog);
NET.setMRAcatalog(MRAcatalog);

```

</td>
<td>

```python
def load_MRA(config: Config, net: ROOT.network):
   logger.info("Loading MRA")
   net.setMRAcatalog(config.MRAcatalog)
```

</td>
</tr>
</table>

#### Create WDM
<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
int BetaOrder = WDM_BETAORDER;	// beta function order for Meyer
int precision = WDM_PRECISION;	// wavelet precision
if(NET.wdmMRA.tag!=0) {		// new catalog format : read BetaOrder,precision from catalog
  BetaOrder=NET.wdmMRA.BetaOrder; 
  precision=NET.wdmMRA.precision;
}

for(int level=cfg.l_high; level>=cfg.l_low; level--) {
  int layers = level>0 ? 1<<level : 0;
  pwdm[cfg.l_high-level] = new WDM<double>(layers,layers,BetaOrder,precision);
  // check if filter lenght is less than cwb scratch length
  double wdmFLen = double(pwdm[cfg.l_high-level]->m_H)/rateANA;    // sec
  if(wdmFLen > cfg.segEdge+0.001) {
     cout << endl;
     cout << "cwb2G::Init : Error - filter length must be <= segEdge !!!" << endl;
     cout << "filter length : " << wdmFLen << " sec" << endl;
     cout << "cwb   scratch : " << cfg.segEdge << " sec" << endl;
     EXIT(1);
  } else {
     cout << "Filter length = " << wdmFLen << " (sec)" << endl;
  }
  // check if the length for time delay amplitudes is less than cwb scratch length
  // the factor 1.5 is used to avoid to use pixels on the border which could be distorted
  double rate  = rateANA>>level;
  if(cfg.segEdge<int(1.5*(cfg.TDSize/rate)+0.5)) {
     cout << endl;
     cout << "cwb2G::Init : Error - segEdge must be > " 
          << "1.5x the length for time delay amplitudes!!!" << endl;
     cout << "TD length : " << cfg.TDSize/rate << " sec" << endl;
     cout << "segEdge   : " << cfg.segEdge << " sec" << endl;
     cout << "Select segEdge > " << int(1.5*(cfg.TDSize/rate)+0.5) << endl << endl;
     EXIT(1);
  } 
  // add WDM to network
  NET.add(pwdm[cfg.l_high-level]); // network vector must be filled starting from max resolution level
}
```
</td>
<td>

```python
def create_wdm(config: Config, net: ROOT.network):
    beta_order = WDM_BETAORDER  # beta function order for Meyer
    precision = WDM_PRECISION  # wavelet precision

    if net.wdmMRA.tag != 0:
        beta_order = net.wdmMRA.BetaOrder
        precision = net.wdmMRA.precision

    wdm_list = []
    for i in range(config.l_low, config.l_high + 1):
        level = config.l_high + config.l_low - i
        layers = 2 ** level if level > 0 else 0
        wdm = ROOT.WDM(np.double)(layers, layers, beta_order, precision)
        wdmFLen = wdm.m_H / config.rateANA

        if wdmFLen > config.segEdge + 0.001:
            logger.error("Filter length must be <= segEdge !!!")
            logger.error("filter length : %s sec", wdmFLen)
            logger.error("cwb   scratch : %s sec", config.segEdge)
            raise ValueError("Filter length must be <= segEdge !!!")
        else:
            logger.info("Filter length = %s (sec)", wdmFLen)

        # check if the length for time delay amplitudes is less than cwb scratch length
        # the factor 1.5 is used to avoid to use pixels on the border which could be distorted
        rate = config.rateANA >> level

        if config.segEdge < int(1.5 * (config.TDSize / rate) + 0.5):
            logger.error("segEdge must be > 1.5x the length for time delay amplitudes!!!")
            logger.error("TD length : %s sec", config.TDSize / rate)
            logger.error("segEdge   : %s sec", config.segEdge)
            logger.error("Select segEdge > %s", int(1.5 * (config.TDSize / rate) + 0.5))
            raise ValueError("segEdge must be > 1.5x the length for time delay amplitudes!!!")

        wdm_list.append(wdm)
        net.add(wdm)

    return wdm_list
```

</td>
</tr>
</table>

#### check if analysis layers are contained in the MRAcatalog

<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
  // level : is the decomposition level
  // layes : are the number of layers along the frequency axis rateANA/(rateANA>>level)
  int check_layers=0;
  for(int level=cfg.l_high; level>=cfg.l_low; level--) {
    int layers = level>0 ? 1<<level : 0;
    for(int j=0;j<NET.wdmMRA.nRes;j++) if(layers==NET.wdmMRA.layers[j]) check_layers++;
  }

  if(check_layers!=nRES) {
    cout << "cwb2G::Init - Error : analysis layers do not match the MRA catalog" << endl;
    cout << endl << "analysis layers : " << endl;
    for(int level=cfg.l_high; level>=cfg.l_low; level--) {
      int layers = level>0 ? 1<<level : 0;
      cout << "level : " << level << " layers : " << layers << endl;
    }
    cout << endl << "MRA catalog layers : " << endl;
    for(int i=0;i<NET.wdmMRA.nRes;i++) 
       cout << "layers : " << NET.wdmMRA.layers[i] << endl;
    EXIT(1);
  } 
  else {
    cout << endl;
    for(int level=cfg.l_high; level>=cfg.l_low; level--) {
      int layers = level>0 ? 1<<level : 0;
      int rate  = rateANA>>level;
      cout << "level : " << level << "\t rate(hz) : " << rate << "\t layers : " << layers
           << "\t df(hz) : " << rateANA/2./double(1<<level)
           << "\t dt(ms) : " << 1000./rate << endl;
    }
    cout << endl;
  }
```
</td>
<td>

```python
```

</td>
</tr>
</table>

#### Check if lagStep compatible with WDM parity

<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
  // This condition is necessary to avoid mixing between odd 
  // and even pixels when circular buffer is used for lag shift
  // The MRAcatalog distinguish odd and even pixels
  int rate_min  = rateANA>>cfg.l_high;
  double dt_max = 1./rate_min;
  if(fmod(rate_min,1.)) {
    cout << "cwb2G::Init - Error : rate min=" << rate_min << "(Hz) is not integer" << endl << endl;
    EXIT(1);  
  }
  if(int(cfg.lagStep*rate_min+0.001)&1) {
    cout << "cwb2G::Init - Error : lagStep=" << cfg.lagStep << "(sec)"
         << " is not a multple of 2*max_time_resolution=" << 2*dt_max << "(sec)" << endl << endl;
    EXIT(1);  
  }
  if(int(cfg.segEdge*rate_min+0.001)&1) {
    cout << "cwb2G::Init - Error : segEdge=" << cfg.segEdge << "(sec)"
         << " is not a multple of 2*max_time_resolution=" << 2*dt_max << "(sec)" << endl << endl;
    EXIT(1);  
  }
  if(int(cfg.segMLS*rate_min+0.001)&1) {
    cout << "cwb2G::Init - Error : segMLS=" << cfg.segMLS << "(sec)"
         << " is not a multple of 2*max_time_resolution=" << 2*dt_max << "(sec)" << endl << endl;
    EXIT(1);  
  }

```
</td>
<td>

```python
```

</td>
</tr>
</table>

#### time-delay filter rate

<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp

  // time-delay filter rate
  if(cfg.fResample>0) {                                 // RESAMPLING
    TDRate = (cfg.fResample>>cfg.levelR)*cfg.upTDF;	
  } else {
    TDRate = (cfg.inRate>>cfg.levelR)*cfg.upTDF;	
  }

```
</td>
<td>

```python
```
</td>
</tr>
</table>

### 3.2 Init Network
<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
for(int i=0; i<nIFO; i++) {
 if(strlen(cfg.ifo[i])>0) pD[i] = new detector(cfg.ifo[i]);        // built in detector
 else                     pD[i] = new detector(cfg.detParms[i]);   // user define detector
}
// set the original sampling rate
for(int i=0; i<nIFO; i++) pD[i]->rate = cfg.fResample>0 ? cfg.fResample : cfg.inRate;
// add detector object to network
for(int i=0; i<nIFO; i++) NET.add(pD[i]);

// set network skymaps 
NET.setSkyMaps(int(cfg.healpix));
NET.setAntenna();

// restore network parameters
NET.constraint(cfg.delta,cfg.gamma);
NET.setDelay(cfg.refIFO);
NET.Edge = cfg.segEdge;
NET.netCC = cfg.netCC;
NET.netRHO = cfg.netRHO;
NET.EFEC = cfg.EFEC;
NET.precision = cfg.precision;
NET.nSky = cfg.nSky;
NET.setRunID(runID);
NET.setAcore(cfg.Acore);
NET.optim=cfg.optim;
NET.pattern=cfg.pattern;

// set sky mask
if(strlen(cfg.skyMaskFile)>0) SetSkyMask(&NET,&cfg,cfg.skyMaskFile,'e'); 
if(strlen(cfg.skyMaskCCFile)>0) SetSkyMask(&NET,&cfg,cfg.skyMaskCCFile,'c'); 
```
</td>
<td>

```python
def init_network(run_id, config: dict):
   logger.info("Initializing network")
   net = ROOT.network()
   for ifo in config['ifo']:
      logger.info("Adding ifo %s", ifo)
      det = ROOT.detector(ifo)

      det.rate = config["inRate"] if not config['fResample'] else config['fResample']
      net.add(det)

   # set network skymaps
   logger.info("Setting skymaps")
   net.setSkyMaps(int(config['healpix']))
   net.setAntenna()

   # restore network parameters
   logger.info("Restoring network parameters")
   net.constraint(config['delta'], config['gamma'])
   net.setDelay(config['refIFO'])
   net.Edge = config['segEdge']
   net.netCC = config['netCC']
   net.netRHO = config['netRHO']
   net.EFEC = config['EFEC']
   net.precision = config['precision']
   net.nSky = config['nSky']
   net.setRunID(run_id)
   net.setAcore(config['Acore'])
   net.optim = config['optim']
   net.pattern = config['pattern']

   # set sky mask
   logger.info("Setting sky mask")
   tmp_cfg = ROOT.CWB.config()
   tmp_cfg.healpix = config['healpix']
   tmp_cfg.Theta1 = config['Theta1']
   tmp_cfg.Theta2 = config['Theta2']
   tmp_cfg.Phi1 = config['Phi1']
   tmp_cfg.Phi2 = config['Phi2']
```
</td>
</tr>
</table>


## 4. Coherence


Select the significant pixels

Loop over resolution levels (nRES)

 - Loop over detectors (cwb::nIFO)
   - Compute the maximum energy of TF pixels (WSeries<double>::maxEnergy)
 - Set pixel energy selection threshold (network::THRESHOLD)
 - Loop over time lags (network::nLag)
   - Select the significant pixels (network::getNetworkPixels)
   - Single resolution clustering (network::cluster)
   - Store selected pixels to job file (netcluster::write)


### 4.1 produce TF maps with max over the sky energy

<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
for(int i=0; i<nRES; i++) {
  double alp=0;
  for(int n=0; n<nIFO; n++) {
    alp+=NET.getifo(n)->getTFmap()->maxEnergy(
                            *hot[n],*pwdm[i],mTau,upN,NET.pattern);
    // restore the frequency boundaries changed by the maxEnergy call
    NET.getifo(n)->getTFmap()->setlow(cfg.fLow);
    NET.getifo(n)->getTFmap()->sethigh(cfg.fHigh);
    if(singleDetector) {
      *(NET.getifo(1)->getTFmap()) = *(NET.getifo(0)->getTFmap());
      break;
    }
  }
}
```
</td>
<td>

```python
def max_energy(h: TimeSeries, pwdm, m_tau: float, up_N: int, pattern: int):
   """
   produce TF maps with max over the sky energy
   Input
   :param h: input time series
   :param pwdm: wavelet used for the transformation
   :param m_tau: range of time delays
   :param up_N: downsample factor to obtain coarse TD steps
   :param pattern: clustering pattern
   :return:
   """
```
</td>
</tr>
</table>

### 4.2 threshold on pixel energy

<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
for(int i=0; i<nRES; i++) {
      alp /= nIFO;
      if(NET.pattern!=0) { 
        Eo = NET.THRESHOLD(cfg.bpp,alp);          
      } else {
        Eo = NET.THRESHOLD(cfg.bpp); 
      }
      cout.precision(5);
      cout<<"thresholds in units of noise variance: Eo="<<Eo<<" Emax="<<Eo*2<<endl;
      // add infos to history
      sprintf(info,"-RES:%d-THR:%g",i,Eo);
      PrintAnalysisInfo(CWB_STAGE_COHERENCE,"cwb2G::Coherence",info,false);
  
      double TL = NET.setVeto(cfg.iwindow);
      cout<<"live time in zero lag: "<<TL<<endl;        // set veto array
      if(TL <= 0.) {froot->Close();EXIT(1);}  	        // exit if live time is zero 
}
```
</td>
<td>

```python

```
</td>
</tr>
</table>


### 4.3 init sparse table (used in supercluster stage : set the TD filter size)
<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
for(int i=0; i<nRES; i++) {
      pwdm[i]->setTDFilter(cfg.TDSize, 1); 
      for(int n=0; n<nIFO; n++) {
         WS[n].Forward(*hot[n],*pwdm[i]);
         vSS[n].SetMap(&WS[n]);
         vSS[n].SetHalo(mTau);
         if(singleDetector) {
           WS[1]=WS[0];
           vSS[1].SetMap(&WS[1]);
           vSS[1].SetHalo(mTau);
           break;
         }
      }
}
```
</td>
<td>

```python

```
</td>
</tr>
</table>

### 4.4 select pixels

<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
for(int i=0; i<nRES; i++) {
      if(cfg.simulation) {cout<<"ifactor|clusters|pixels ";cout.flush();}
      else               {cout<<"lag|clusters|pixels ";    cout.flush();}
      int csize_tot=0;int psize_tot=0; 
      for(int j=0; j<(int)NET.nLag; j++) {

         NET.getNetworkPixels(j,Eo);
         pwc = NET.getwc(j);
         if(NET.pattern!=0) {
            NET.cluster(2,3);
            wc.cpf(*(pwc),false);
            wc.select(const_cast<char*>("subrho"),cfg.select_subrho);
            wc.select(const_cast<char*>("subnet"),cfg.select_subnet);
            pwc->cpf(wc,false);
         } else NET.cluster(1,1);
         // store cluster into temporary job file
         int cycle = cfg.simulation ? ifactor : Long_t(pwc->shift);
         pwc->write(jfile,"coherence","clusters",0,cycle);
         pwc->write(jfile,"coherence","clusters",-1,cycle,-(rateANA>>(cfg.l_high-i)));
         cout<<cycle<<"|"<<pwc->csize()<<"|"<<pwc->size()<<" ";cout.flush();
         csize_tot+=pwc->csize(); psize_tot+=pwc->size(); 

         // add core pixels to sparse table
         for(int n=0; n<nIFO; n++) vSS[n].AddCore(n,pwc);

         pwc->clear();
      }
}
```
</td>
<td>

```python

```
</td>
</tr>
</table>

Key output: cluster `pwc`, spare table `vSS`

## 5. Supercluster


Multi resolution clustering & Rejection of the sub-threshold clusters

Loop over time lags

 - Read clusters from job file (netcluster::read)
 - Multi resolution clustering (netcluster::supercluster)
 - Compute for each pixel the time delay amplitudes (netcluster::loadTDampSSE)
 - Rejection of the sub-threshold clusters (network::subNetCut)
 - Defragment clusters (netcluster::defragment)
 - Store superclusters to job file (netcluster::write)

### 5.1 Build & Write to job file the sparse TF maps (WriteSparseTFmap)

<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
// decrease skymap resolution to improve subNetCut performances
double skyres=0;
skyres = cfg.healpix>MIN_SKYRES_HEALPIX ? MIN_SKYRES_HEALPIX : 0;
if(skyres) {
NET.setSkyMaps(int(skyres));
NET.setAntenna();
NET.setDelay(cfg.refIFO);
// the down resampling of the skymask works only for the built-in skymask
if(strlen(cfg.skyMaskFile)>0)   SetSkyMask((network*)(&NET),&cfg,cfg.skyMaskFile,'e',skyres);
if(strlen(cfg.skyMaskCCFile)>0) SetSkyMask((network*)(&NET),&cfg,cfg.skyMaskCCFile,'c',skyres);
}

for(int i=0; i<nIFO; i++) pTF[i] = pD[i]->getTFmap();
// set low-rate TD filters 
for(int k=0;k<nRES;k++) pwdm[k]->setTDFilter(cfg.TDSize, 1); 
```
</td>
<td>

```python

```
</td>
</tr>
</table>

### 5.2 read sparse map from job file

<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp  
for(int n=0; n<nIFO; n++) {
    pD[n]->sclear();   // clear vector with sparse maps
    for(int i=0; i<nRES; i++) {
      char swname[32];
      if(cfg.simulation) sprintf(swname,"csparse/%s-level:%d:%d",ifo[n],ifactor,i+cfg.l_low);
      else               sprintf(swname,"csparse/%s-level:%d",ifo[n],i+cfg.l_low);
      SSeries<double>* psw;
      if(ifile!=NULL) psw = (SSeries<double>*)ifile->Get(swname);	
      else            psw = (SSeries<double>*)jfile->Get(swname);	
      if(psw==NULL) {
        cout << "cwb2G::SuperCluster : sparse map " << swname
             << " not exist in job file" << endl;EXIT(1);
      }
      SSeries<double> SS = *psw;
      pD[n]->vSS.push_back(SS);
      delete psw;
    }
    cout<<endl;
}
```
</td>
<td>

```python

```
</td>
</tr>
</table>


### 5.3 read data

<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
for(int j=0; j<(int)lags; j++) {

  int cycle = cfg.simulation ? ifactor : Long_t(NET.wc_List[j].shift);

  // read cluster metadata
  if(ifile!=NULL) wc.read(ifile,"coherence","clusters",0,cycle);	
  else            wc.read(jfile,"coherence","clusters",0,cycle);	
  // read clusters from temporary job file, loop over TF resolutions
  if(ifile!=NULL) {
    for(int i=nRES-1; i>=0; i--)     // reverse loop is faster loading cluster (?)
      wc.read(ifile,"coherence","clusters",-2,cycle,-(rateANA>>(i+cfg.l_low))); 
  } else {           
    for(int i=nRES-1; i>=0; i--)     // reverse loop is faster loading cluster (?)
      wc.read(jfile,"coherence","clusters",-2,cycle,-(rateANA>>(i+cfg.l_low))); 
  }
  cout<<"-----------------------------------------------------"<<endl; 
  char cycle_name[32];
  if(cfg.simulation) sprintf(cycle_name," factor[%d]=%g",ifactor,cfg.factors[ifactor]);
  else               sprintf(cycle_name," lag=%d",cycle); 
  cout<<"-> Processing "   <<cycle_name<<" ..."<<endl;
  cout<<"   --------------------------------------------------"<<endl; 
  cout<<"   coher  clusters|pixels      : "
      <<setfill(' ')<<setw(6)<<wc.csize()<<"|"<<wc.size()<<endl;
```

</td>
<td>

```python

```
</td>
</tr>
</table>

### 5.4 supercluster analysis

<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
for(int j=0; j<(int)lags; j++) {
  if(cfg.l_high==cfg.l_low) wc.pair=false;		// if only one resolution is used pair is false 
  if(NET.pattern!=0) wc.pair=false;                 // if other than pattern=0 - allow one resolution cluster
  wc.supercluster('L',NET.e2or,cfg.TFgap,false);  	// likehood2G
  cout<<"   super  clusters|pixels      : "
      <<setfill(' ')<<setw(6)<<wc.esize(0)<<"|"<<wc.psize(0)<<endl;
}
```
</td>
<td>

```python

```
</td>
</tr>
</table>


<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
for(int j=0; j<(int)lags; j++) {
  // defragmentation for pattern != 0
  if(NET.pattern!=0) {
     wc.defragment(cfg.Tgap,cfg.Fgap);                                
     cout<<"   defrag clusters|pixels      : "
         <<setfill(' ')<<setw(6)<<wc.esize(0)<<"|"<<wc.psize(0)<<"\n";
  }

  // copy selected clusters to network
  pwc = NET.getwc(j);
  pwc->cpf(wc, false);

  // apply subNetCut() only for pattern=0 || cfg.subnet>0 || cfg.subcut>0 || cfg.subnorm>0 || cfg.subrho>=0
  if(NET.pattern==0 || cfg.subnet>0 || cfg.subcut>0 || cfg.subnorm>0 || cfg.subrho>=0) {
     if(cfg.subacor>0) NET.acor=cfg.subacor;	// set Acore for subNetCuts
     if(cfg.subrho>0)  NET.netRHO=cfg.subrho;	// set netRHO for subNetCuts
     NET.setDelayIndex(hot[0]->rate());
     pwc->setcore(false);   
     int psel = 0;
     while(1) {
       count = pwc->loadTDampSSE(NET, 'a', cfg.BATCH, cfg.LOUD);
       psel += NET.subNetCut((int)j,cfg.subnet,cfg.subcut,cfg.subnorm,NULL);
       int ptot = pwc->psize(1)+pwc->psize(-1);
       double pfrac = ptot>0 ? double(psel)/double(ptot) : 0.;
       //cout<<"selected pixels: "<<psel<<"|"<<ptot<<", fraction: "<<pfrac<<" "<<cfg.subnet<<" "<<cfg.subcut<<endl;
       if(count<10000) break;
     }
     cout<<"   subnet clusters|pixels      : "
         <<setfill(' ')<<setw(6)<<NET.events()<<"|"<<pwc->psize(-1)<<"\n";
     if(cfg.subacor>0) NET.acor=cfg.Acore;		// restore Acore
     if(cfg.subrho>0)  NET.netRHO=cfg.netRHO;	// restore netRHO
  }
  if(NET.pattern==0) {
     // defragmentation
     pwc->defragment(cfg.Tgap,cfg.Fgap);    
     cout<<"   defrag clusters|pixels      : "
         <<setfill(' ')<<setw(6)<<NET.events()<<"|"<<pwc->psize(-1)<<"\n";
  }

  nevt += NET.events();
  nnn  += pwc->psize(-1);
  mmm  += pwc->psize(1)+pwc->psize(-1);

  // store cluster into temporary job file [NEWSS]
  pwc->write(jfile,"supercluster","clusters",0,cycle);
  pwc->write(jfile,"supercluster","clusters",-1,cycle);
  //cout<<cycle<<"|"<<pwc->csize()<<"|"<<pwc->size()<<" ";cout.flush();

  pwc->clear();
  cout<<endl;cout.flush();
}
```
</td>
<td>

```python

```
</td>
</tr>
</table>

Key output: cluster `pwc`

## 6. Likelihood

Event reconstruction & parameters estimation

Read sparse map from job file

Loop over time lags

 - Read cluster list from job file (netcluster::read)
 - Loop over cluster list
   - Read pixels (netcluster::read)
   - Compute for each pixel the time delay amplitudes (netcluster::loadTDampSSE)
   - Event reconstruction+parameter estimation (network::likelihood2G)
   - Store event parameters to job file (netevent::output)
   - If(config::cedDump>0) Generate Coherent Event Display (CWB::ced)


### 6.1 loop over the cluster list

<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
for(int k=0;k<(int)clist.size();k++) {	// loop over the cluster list 
      pwc->read(jfile,"supercluster","clusters",nmax,cycle,0,clist[k]);
    
      wavearray<double> cid = pwc->get((char*)"ID",  0,'S',0); // get cluster ID
      if(!cid.size()) continue;
      
      int id = size_t(cid.data[cid.size()-1]+0.1);
      pwc->setcore(false,id);
      pwc->loadTDampSSE((network&)NET, 'a', cfg.BATCH, cfg.BATCH);  // attach TD amp to pixels
    
      int lag = j;
    
      int ID = cfg.cedDump ? -id : 0;
      int selected_core_pixels = 0;
      if(NET.pattern>0) { 
        selected_core_pixels = NET.likelihoodWP(cfg.search, lag, ID, NULL, cfg.Search);
      } else { 
        selected_core_pixels = NET.network::likelihood2G(cfg.search, lag, ID, NULL);
      }
      if(!cfg.outPlugin) { 	// if true then output to root file is provided by the user plugin
        double ofactor=0;
        if(cfg.simulation==4)      ofactor=-factor;
        else if(cfg.simulation==3) ofactor=-ifactor;
        else                       ofactor=factor;
        if(cfg.dump) netburst->dopen(outDump,const_cast<char*>("a"),false);
        netburst->output(net_tree,&NET,id,lag,ofactor);
        if(cfg.dump) netburst->dclose();
      } 
      int rejected_weak_pixels = 0;
      int rejected_loud_pixels = 0;
    
      bool detected = (bool)(NET.network::getwc(j)->sCuts[k] == -1);
    
      // print reconstructed event  
      cout<<"   cluster-id|pixels: "<<setfill(' ')<<setw(5)<<clist[k]<<"|"<<pwc->size()-npixels;  
      if(detected) cout << "\t -> SELECTED !!!" << endl;
      else 	   cout << "\t <- rejected    " << endl;
      cout.flush();
}
```
</td>
<td>

```python

```
</td>
</tr>
</table>

### 6.2 Store data

<table>
<tr>
<th>C++</th>
<th>Python</th>
</tr>
<tr>
<td>

```cpp
for(int k=0;k<(int)clist.size();k++) {	// loop over the cluster list 
      if(((k==0)||detected)&&(jobfOptions&CWB_JOBF_SAVE_LIKELIHOOD)) {
        TFile* ifile = jfile;
        if(xname!=jname) {
          ifile = new TFile(jname,"UPDATE");
          if(ifile==NULL||!ifile->IsOpen()) {
            cout << "cwb2G::Likelihood - Error : file " << jname << " not found" <<  endl; EXIT(1); }
        }
        pwc->write(ifile,"likelihood","clusters",0,cycle);
        pwc->write(ifile,"likelihood","clusters",-1,cycle,0,k+1);
        if(detected) cout<<"saved"<<endl;cout.flush();
        ifile->Write();
        if(xname!=jname) ifile->Close();
      }

      if(detected) nevents++;
      npixels=pwc->size();
}
```
</td>
<td>

```python

```
   
</td>
</tr>
</table>

